// Generated by CoffeeScript 1.7.1
(function() {
  var MQTTRelay, events, mqtt,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  mqtt = require('mqtt');

  events = require('events');

  MQTTRelay = (function(_super) {
    __extends(MQTTRelay, _super);

    function MQTTRelay(config, bayeux) {
      this.config = config;
      this.bayeux = bayeux;
      this.subscriptions = {};
    }

    MQTTRelay.prototype.added = function() {
      var clientOpts;
      clientOpts = this.config.client_options || {};
      this.mqttClient = mqtt.connect(this.config.broker_url, clientOpts);
      this.fayeClient = this.bayeux.getClient();
      console.log("MQTT relay enabled. Broadcasts will be relayed to and from " + (this.mqttUrl()) + ".");
      return this.mqttClient.on('connect', (function(_this) {
        return function() {
          _this.emit('connect', _this.config.broker_url, clientOpts);
          return _this.mqttClient.on('message', function(topic, message) {
            var payload;
            payload = JSON.parse(message);
            _this.emit('receive', topic, payload);
            payload.mqttRelay = 'in';
            return _this.fayeClient.publish(topic, payload);
          });
        };
      })(this));
    };

    MQTTRelay.prototype.incoming = function(message, callback) {
      if ((message.data != null) && message.data.mqttRelay) {
        return callback(message);
      }
      if (message.channel.match(/^\/meta\//)) {
        if (message.channel.match(/^\/meta\/subscribe/)) {
          return this.subscribeToMQTT(message, callback);
        } else {
          return callback(message);
        }
      } else {
        return this.publishToMQTT(message, callback);
      }
    };

    MQTTRelay.prototype.subscribeToMQTT = function(subMessage, callback) {
      var clientId, qos, topic;
      topic = subMessage.subscription.replace('*', '#');
      clientId = subMessage.clientId;
      if ((this.subscriptions[topic] != null) && Object.keys(this.subscriptions[topic]).length > 0) {
        this.subscriptions[topic][clientId] = true;
        this.emit('sub_skip', topic, clientId);
        return callback(subMessage);
      } else {
        this.subscriptions[topic] = {};
        this.subscriptions[topic][clientId] = 'pending';
      }
      qos = 1;
      return this.mqttClient.subscribe(topic, {
        qos: qos
      }, (function(_this) {
        return function(err, granted) {
          if (err != null) {
            console.error("MQTT", "FAILED TO SUBSCRIBE TO TOPIC", topic, err);
            _this.emit('sub_failure', topic, clientId, {
              qos: qos
            }, err);
            subMessage.error = err;
            return callback(subMessage);
          } else {
            granted.forEach(function(grant) {
              _this.subscriptions[grant.topic][clientId] = 'confirmed';
              return _this.emit('sub_success', grant.topic, clientId, {
                qos: grant.qos
              });
            });
            return callback(subMessage);
          }
        };
      })(this));
    };

    MQTTRelay.prototype.publishToMQTT = function(message, callback) {
      var opts, payload, qos, retain, topic;
      topic = message.channel;
      payload = message.data;
      payload.mqttRelay = 'out';
      qos = 1;
      retain = false;
      opts = {
        qos: qos,
        retain: retain
      };
      return this.mqttClient.publish(topic, JSON.stringify(payload), opts, (function(_this) {
        return function() {
          _this.emit('pub_success', topic, payload, opts);
          return callback(message);
        };
      })(this));
    };

    MQTTRelay.prototype.mqttUrl = function() {
      return this.config.broker_url;
    };

    return MQTTRelay;

  })(events.EventEmitter);

  exports.MQTTRelay = MQTTRelay;

}).call(this);
