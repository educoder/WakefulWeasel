// Generated by CoffeeScript 1.4.0
(function() {
  var URL, Weasel, WebSocket, WebSocketServer, events, mubsub,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  WebSocket = require('ws');

  WebSocketServer = WebSocket.Server;

  URL = require('url');

  mubsub = require('mubsub');

  events = require('events');

  Weasel = (function(_super) {

    __extends(Weasel, _super);

    function Weasel(options) {
      var _base, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      this.options = options;
      if ((_ref = (_base = this.options).port) == null) {
        _base.port = 7777;
      }
      if (options.pubsub != null) {
        this.pubusub = options.pubsub;
      }
      this.logger = (_ref1 = options.logger) != null ? _ref1 : console;
      this.websockets = [];
      this.subscribers = {};
    }

    Weasel.prototype.listen = function() {
      var _this = this;
      this.wss = new WebSocketServer({
        port: this.options.port
      });
      this.wss.on('listening', function() {
        return _this.emit('listening');
      });
      return this.wss.on('connection', function(ws) {
        var cid;
        cid = _this.websockets.length;
        _this.websockets[cid] = ws;
        ws.on('close', function() {
          return delete _this.websockets[cid];
        });
        return ws.on('message', function(json) {
          var req;
          req = JSON.parse(json);
          req.cid = cid;
          ws.cid = cid;
          return Weasel.protocol[req.type].call(_this, req);
        });
      });
    };

    Weasel.prototype.stop = function() {
      this.wss.close();
      return this.emit('stopped');
    };

    Weasel.prototype.broadcast = function(rloc, bcast) {
      var send, ws, _i, _len, _ref, _results,
        _this = this;
      _ref = this.subscribers[rloc.url];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ws = _ref[_i];
        send = function() {
          _this.logger.log("< " + rloc.url + "#", "#" + bcast.bid, bcast.action, bcast.data, bcast.origin);
          return ws.send(JSON.stringify(bcast));
        };
        if (ws.readyState === WebSocket.OPEN) {
          _results.push(send());
        } else if (ws.readyState === WebSocket.CONNECTING) {
          _results.push(ws.on('open', send));
        } else if (ws.readyState === WebSocket.CLOSING) {
          _results.push(this.logger.warn("WebSocket is closing; cannot send update!"));
        } else if (ws.readyState === WebSocket.CLOSED) {
          _results.push(this.logger.warn("WebSocket is closed; cannot send update!"));
        } else {
          _results.push(this.logger.error("WebSocket is in a weird state!", ws.readyState));
        }
      }
      return _results;
    };

    Weasel.protocol = {
      PUBLISH: function(req) {
        var bcast, rloc;
        rloc = new Weasel.ResourceLocator(req.url);
        bcast = {
          action: req.action,
          data: req.data
        };
        if (req.bid != null) {
          bcast.bid = req.bid;
        }
        if (req.origin != null) {
          bcast.origin = req.origin;
        }
        this.pubsub.publish(rloc, bcast);
        this.emit('published', rloc, bcast);
        return this.logger.log("> " + rloc.url, bcast);
      },
      SUBSCRIBE: function(req) {
        var rloc, ws,
          _this = this;
        rloc = new Weasel.ResourceLocator(req.url);
        ws = this.websockets[req.cid];
        if (this.subscribers[rloc.url] != null) {
          this.subscribers[rloc.url].push(ws);
          this.emit('subscribed', ws);
          this.logger.log("s " + rloc.url + " " + req.cid);
        } else {
          this.subscribers[rloc.url] = [];
          this.subscribers[rloc.url].push(ws);
          this.emit('subscribed', ws);
          this.pubsub.subscribe(rloc, function(bcast) {
            return _this.broadcast(rloc, bcast);
          });
          this.emit('subscription', rloc);
          this.logger.log("S " + rloc.url + " " + req.cid);
        }
        return ws.on('close', function() {
          var idx;
          idx = _this.subscribers[rloc.url].indexOf(ws);
          _this.subscribers[rloc.url].splice(idx, 1);
          _this.emit('unsubscribed', ws);
          _this.logger.log("u " + rloc.url + " " + req.cid);
          if (_this.subscribers[rloc.url].length === 0) {
            _this.logger.log("U " + rloc.url);
            _this.pubsub.unsubscribe(rloc);
            return _this.emit('unsubscription', rloc);
          }
        });
      }
    };

    return Weasel;

  })(events.EventEmitter);

  Weasel.ResourceLocator = (function() {

    function ResourceLocator(url) {
      var collection, db, id, normalizedUrl, parsedUrl, _ref;
      parsedUrl = URL.parse(url);
      _ref = parsedUrl.pathname.replace(/^\//, '').split("/"), db = _ref[0], collection = _ref[1], id = _ref[2];
      if ((db != null) && (collection != null) && (id != null)) {
        normalizedUrl = "/" + db + "/" + collection + "/" + id;
      } else if ((db != null) && (collection != null)) {
        normalizedUrl = "/" + db + "/" + collection;
      } else {
        throw new Error("Invalid resource URL " + originalUrl, originalUrl);
        this.logger.error("! " + originalUrl);
      }
      this.url = normalizedUrl;
      this.db = db;
      this.collection = collection;
      if (id != null) {
        this.id = id;
      }
    }

    ResourceLocator.prototype.toString = function() {
      return this.url;
    };

    return ResourceLocator;

  })();

  exports.Weasel = Weasel;

}).call(this);
