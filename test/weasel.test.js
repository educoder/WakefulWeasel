// Generated by CoffeeScript 1.4.0
(function() {
  var DROWSY_URL, Deferred, PORT, PUBSUB_BACKENDS, TEST_COLLECTION, TEST_DB, WAKEFUL_URL, Weasel, WebSocket, mubsub, should, _,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  should = require('chai').should();

  _ = require('underscore');

  Deferred = require('dfrrd');

  Weasel = require('../weasel').Weasel;

  WebSocket = require('ws');

  DROWSY_URL = "http://localhost:9292";

  WAKEFUL_URL = void 0;

  TEST_DB = 'weasel_test';

  TEST_COLLECTION = 'tests';

  PORT = 7778;

  PUBSUB_BACKENDS = {};

  mubsub = require('../mubsub');

  PUBSUB_BACKENDS['mubsub'] = mubsub.Mubsub;

  describe('WakefulWeasel', function() {
    beforeEach(function(done) {
      var logger;
      this.fakePubsub = {
        publish: function(rloc, bcast) {},
        subscribe: function(rloc, deliver) {},
        unsubscribe: function(rloc) {}
      };
      WAKEFUL_URL = "ws://localhost:";
      logger = {
        error: function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return console.error.apply(console, args);
        },
        warn: function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return console.warn.apply(console, args);
        },
        log: function() {}
      };
      this.weasel = new Weasel({
        logger: logger,
        port: PORT
      });
      WAKEFUL_URL = "ws://localhost:" + PORT;
      this.weasel.pubsub = this.fakePubsub;
      this.weasel.on('listening', function() {
        return done();
      });
      this.weasel.listen();
      return PORT++;
    });
    describe("#stop", function() {
      return it("should stop the server", function(done) {
        this.weasel.on('stopped', function() {
          return done();
        });
        return this.weasel.stop();
      });
    });
    describe(".protocol", function() {
      describe("#SUBSCRIBE", function() {
        it("should trigger the pubsub's subscribe() only for the first subscriber to a URL", function(done) {
          var req1, req2, reqCount, rloc1, rloc2, subs, url1, url2, ws,
            _this = this;
          reqCount = 0;
          this.weasel.on('subscribed', function() {
            return reqCount++;
          });
          subs = {};
          this.weasel.pubsub.subscribe = function(rloc, deliver) {
            var _name, _ref;
            if ((_ref = subs[_name = rloc.url]) == null) {
              subs[_name] = 0;
            }
            subs[rloc.url]++;
            if (reqCount === 3) {
              subs[rloc1.url].should.equal(1);
              subs[rloc2.url].should.equal(1);
              _this.weasel.subscribers[rloc1.url].length.should.equal(2);
              _this.weasel.subscribers[rloc2.url].length.should.equal(1);
              return done();
            }
          };
          url1 = "" + DROWSY_URL + "/" + TEST_DB + "/" + TEST_COLLECTION + "/000000000000000000000001";
          url2 = "" + DROWSY_URL + "/" + TEST_DB + "/" + TEST_COLLECTION + "/000000000000000000000002";
          rloc1 = new Weasel.ResourceLocator(url1);
          rloc2 = new Weasel.ResourceLocator(url2);
          req1 = {
            type: 'SUBSCRIBE',
            url: url1
          };
          req2 = {
            type: 'SUBSCRIBE',
            url: url2
          };
          ws = new WebSocket(WAKEFUL_URL);
          return ws.on('open', function() {
            ws.send(JSON.stringify(req1));
            ws.send(JSON.stringify(req1));
            return ws.send(JSON.stringify(req2));
          });
        });
        it("should be able to handle subscriptions from multiple WebSockets", function(done) {
          var req1, reqCount, rloc1, subs, url1, ws1, ws2, ws3,
            _this = this;
          reqCount = 0;
          this.weasel.on('subscribed', function() {
            var subscribers, uniqSubscribers;
            reqCount++;
            if (reqCount === 4) {
              subscribers = _this.weasel.subscribers[rloc1.url];
              subscribers.length.should.equal(4);
              uniqSubscribers = _.uniq(subscribers);
              uniqSubscribers.length.should.equal(3);
              subs[rloc1.url].should.equal(1);
              return done();
            }
          });
          url1 = "" + DROWSY_URL + "/" + TEST_DB + "/" + TEST_COLLECTION + "/000000000000000000000001";
          rloc1 = new Weasel.ResourceLocator(url1);
          subs = {};
          this.weasel.pubsub.subscribe = function(rloc, deliver) {
            var _name, _ref;
            if ((_ref = subs[_name = rloc.url]) == null) {
              subs[_name] = 0;
            }
            return subs[rloc.url]++;
          };
          req1 = {
            type: 'SUBSCRIBE',
            url: url1
          };
          ws1 = new WebSocket(WAKEFUL_URL);
          ws1.on('open', function() {
            return this.send(JSON.stringify(req1));
          });
          ws2 = new WebSocket(WAKEFUL_URL);
          ws2.on('open', function() {
            this.send(JSON.stringify(req1));
            return this.send(JSON.stringify(req1));
          });
          ws3 = new WebSocket(WAKEFUL_URL);
          return ws3.on('open', function() {
            return this.send(JSON.stringify(req1));
          });
        });
        return it("should unsubscribe correctly when the WebSocket closes", function(done) {
          var req1, req2, reqCount, rloc1, rloc2, unsubscribed, url1, url2, ws1, ws2,
            _this = this;
          reqCount = 0;
          this.weasel.on('subscribed', function() {
            reqCount++;
            if (reqCount === 3) {
              _this.weasel.subscribers[rloc1.url].length.should.equal(2);
              _this.weasel.subscribers[rloc2.url].length.should.equal(1);
              return ws1.close();
            }
          });
          unsubscribed = false;
          this.weasel.pubsub.unsubscribe = function(rloc) {
            _this.weasel.subscribers[rloc1.url].length.should.equal(1);
            _this.weasel.subscribers[rloc2.url].length.should.equal(0);
            return unsubscribed = true;
          };
          this.weasel.on('unsubscription', function() {
            _this.weasel.subscribers[rloc1.url].length.should.equal(1);
            _this.weasel.subscribers[rloc2.url].length.should.equal(0);
            unsubscribed.should.be["true"];
            return done();
          });
          url1 = "" + DROWSY_URL + "/" + TEST_DB + "/" + TEST_COLLECTION + "/000000000000000000000001";
          url2 = "" + DROWSY_URL + "/" + TEST_DB + "/" + TEST_COLLECTION + "/000000000000000000000002";
          rloc1 = new Weasel.ResourceLocator(url1);
          rloc2 = new Weasel.ResourceLocator(url2);
          req1 = {
            type: 'SUBSCRIBE',
            url: url1
          };
          req2 = {
            type: 'SUBSCRIBE',
            url: url2
          };
          ws1 = new WebSocket(WAKEFUL_URL);
          ws1.on('open', function() {
            this.send(JSON.stringify(req1));
            return this.send(JSON.stringify(req2));
          });
          ws2 = new WebSocket(WAKEFUL_URL);
          return ws2.on('open', function() {
            return this.send(JSON.stringify(req1));
          });
        });
      });
      return describe("#PUBLISH", function() {
        it("should trigger the pubsub's publish()", function(done) {
          var req, rloc1, url1, ws,
            _this = this;
          this.weasel.pubsub.publish = function(rloc, bcast) {
            bcast.action.should.equal('update');
            bcast.data.foo.should.equal('blah');
            bcast.origin.should.equal('test1');
            return done();
          };
          url1 = "" + DROWSY_URL + "/" + TEST_DB + "/" + TEST_COLLECTION + "/000000000000000000000001";
          rloc1 = new Weasel.ResourceLocator(url1);
          req = {
            type: 'PUBLISH',
            url: url1,
            action: 'update',
            data: {
              foo: 'blah'
            },
            origin: 'test1'
          };
          ws = new WebSocket(WAKEFUL_URL);
          return ws.on('open', function() {
            return ws.send(JSON.stringify(req));
          });
        });
        return it("should broadcast to all subscribers for a doc URL", function(done) {
          return done();
        });
      });
    });
    return describe('PubSub Backends', function() {
      before(function() {
        return this.WSClient = (function(_super) {

          __extends(_Class, _super);

          function _Class() {
            return _Class.__super__.constructor.apply(this, arguments);
          }

          _Class.prototype.sendWhenReady = function(data) {
            if (this.readyState === WebSocket.OPEN) {
              return this.send(JSON.stringify(data));
            } else {
              return this.on('open', function() {
                return this.send(JSON.stringify(data));
              });
            }
          };

          return _Class;

        })(WebSocket);
      });
      return Object.keys(PUBSUB_BACKENDS).forEach(function(name) {
        var backend;
        backend = PUBSUB_BACKENDS[name];
        return describe(name, function() {
          beforeEach(function() {
            return this.weasel.pubsub = new backend({
              logger: this.weasel.logger
            });
          });
          it("should transmit doc broadcast to all subscribers of doc", function(done) {
            var clients, i, received, reqPub1, reqSub1, rloc1, subCount, url1, ws, _i, _j, _len;
            url1 = "" + DROWSY_URL + "/" + TEST_DB + "/" + TEST_COLLECTION + "/000000000000000000000001";
            rloc1 = new Weasel.ResourceLocator(url1);
            reqSub1 = {
              type: 'SUBSCRIBE',
              url: url1
            };
            reqPub1 = {
              type: 'PUBLISH',
              url: url1,
              action: 'update',
              data: {
                foo: 'blah'
              },
              origin: 'test1'
            };
            clients = [];
            for (i = _i = 1; _i <= 3; i = ++_i) {
              ws = new this.WSClient(WAKEFUL_URL);
              clients.push(ws);
            }
            received = [];
            for (_j = 0, _len = clients.length; _j < _len; _j++) {
              ws = clients[_j];
              ws.sendWhenReady(reqSub1);
              ws.on('message', function(msg) {
                var bcast;
                bcast = JSON.parse(msg);
                received.push(bcast);
                if (received.length === clients.length) {
                  return done();
                }
              });
            }
            subCount = 0;
            return this.weasel.on('subscribed', function() {
              subCount++;
              if (subCount === clients.length) {
                return clients[0].sendWhenReady(reqPub1);
              }
            });
          });
          it("should transmit doc and collection broadcast to all subscribers of collection", function(done) {
            var clients, coll_rloc, coll_url, doc_rloc1, doc_rloc2, doc_rloc3, doc_url1, doc_url2, doc_url3, i, received, reqPub, reqSub, subCount, ws, _i, _j, _len;
            doc_url1 = "" + DROWSY_URL + "/" + TEST_DB + "/" + TEST_COLLECTION + "/000000000000000000000001";
            doc_rloc1 = new Weasel.ResourceLocator(doc_url1);
            doc_url2 = "" + DROWSY_URL + "/" + TEST_DB + "/" + TEST_COLLECTION + "/000000000000000000000002";
            doc_rloc2 = new Weasel.ResourceLocator(doc_url2);
            doc_url3 = "" + DROWSY_URL + "/" + TEST_DB + "/" + TEST_COLLECTION + "_foo/000000000000000000000003";
            doc_rloc3 = new Weasel.ResourceLocator(doc_url3);
            coll_url = "" + DROWSY_URL + "/" + TEST_DB + "/" + TEST_COLLECTION;
            coll_rloc = new Weasel.ResourceLocator(coll_url);
            reqSub = {
              type: 'SUBSCRIBE',
              url: coll_url
            };
            reqPub = {
              type: 'PUBLISH',
              url: void 0,
              action: 'update',
              data: void 0,
              origin: 'test1'
            };
            clients = [];
            for (i = _i = 1; _i <= 3; i = ++_i) {
              ws = new this.WSClient(WAKEFUL_URL);
              clients.push(ws);
            }
            received = [];
            for (_j = 0, _len = clients.length; _j < _len; _j++) {
              ws = clients[_j];
              ws.sendWhenReady(reqSub);
              ws.on('message', function(msg) {
                var bar, bcast, foo;
                bcast = JSON.parse(msg);
                received.push(bcast);
                if (received.length === clients.length * 2) {
                  foo = received.reduce((function(tot, r) {
                    return tot + r.data.foo;
                  }), 0);
                  bar = received.reduce((function(tot, r) {
                    return tot + r.data.bar;
                  }), 0);
                  foo.should.equal(3);
                  bar.should.equal(3);
                  return done();
                }
              });
            }
            subCount = 0;
            return this.weasel.on('subscribed', function() {
              subCount++;
              if (subCount === clients.length) {
                reqPub.url = doc_url1;
                reqPub.data = {
                  foo: 1,
                  bar: 0
                };
                clients[0].sendWhenReady(reqPub);
                reqPub.url = doc_url2;
                reqPub.data = {
                  foo: 0,
                  bar: 1
                };
                clients[1].sendWhenReady(reqPub);
                reqPub.url = doc_url3;
                reqPub.data = {
                  foo: 1,
                  bar: 0
                };
                return clients[2].sendWhenReady(reqPub);
              }
            });
          });
          return it("should not crap out if we publish to a url no one is subscribed to", function(done) {
            var doc_rloc1, doc_url1, reqPub, ws;
            doc_url1 = "" + DROWSY_URL + "/" + TEST_DB + "/" + TEST_COLLECTION + "_nope/000000000000000000000099";
            doc_rloc1 = new Weasel.ResourceLocator(doc_url1);
            reqPub = {
              type: 'PUBLISH',
              url: doc_url1,
              action: 'update',
              data: {
                stuff: 'foo'
              },
              origin: 'test1'
            };
            ws = new this.WSClient(WAKEFUL_URL);
            (function() {
              return ws.sendWhenReady(reqPub);
            }).should.not["throw"](Error);
            return this.weasel.on('published', function() {
              return done();
            });
          });
        });
      });
    });
  });

}).call(this);
